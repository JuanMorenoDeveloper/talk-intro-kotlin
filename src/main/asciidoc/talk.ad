= Introducción a Kotlin
:icons: font
:twitter-tag: UDE
:conference-tag:
:talk-tag: Intro Kotlin
:slide-link: http://bit.ly/ude-intro-kotlin
:demo-link: https://github.com/earth001/talk-intro-kotlin
:linkattrs:

include::footer.ad[]

[NOTE.speaker]
====
Contenido de la presentación:

* ¿Qué es Kotlin?
* Características
* Server side development
* Android
* Sintaxis

====

== !
image::kotlin-2-logo-png-transparent.png[background, size=auto]
// https://freebiesupply.com/logos/kotlin-logo-2/

== Contenido
* ¿Qué es Kotlin?
* Características
* Server side development
* Android
* Sintaxis

== ¿Qué es Kotlin?
* Kotlin es un lenguaje de programación con tipado estático para aplicaciones multiplataforma.
* Fue creado por la compañía checa JetBrains en 2010 y liberado bajo licencia Apache en 2011.
* Su nombre proviene de la Isla Kotlin ubicada al oeste de San Petersburgo, Rusia.

== Características

== Conciso

Tiene estructuras que ayudan a reducir el código repetitivo.

== Seguro
Ofrece control en compilación de referencias nulas y conversiones inválidas de clases.

== Interoperable
Es compatible con Java y Android.

== Amistoso

Soportado por los entornos de desarrollo de JetBrains (IntelliJ IDEA, Android Studio) y de terceros.

== Server side development (Backend)

* Expresividad
* Escalabilidad
* Interoperabilidad
* Migración
* Herramientas
* Compatibilidad

[NOTE.speaker]
====
Expresividad: Este lenguaje se destaca en presentar sintaxis innovadora para reducir el código repetitivo y manejar con facilidad abstracciones.

Escalabilidad: Kotlin soporta corrutinas que nos permiten usar programación asincrónica, esto nos beneficia al momento de acceder a recursos (precisamos de ellos solo cuando son necesarios) y nos ofrece facilidad para escalar.
	Interoperabilidad: Es compatible con las librerías y los frameworks Java.

Migración: Puede usarse en conjunto con una base de código Java, lo que nos permite hacer una migración gradual de los sistemas. Esto nos habilita para escribir nuevas funcionalidades con Kotlin y dejar funcionalidades antiguas con Java.

Herramientas: Soporta IDEs populares como IntelliJ y Eclipse, además ofrece plugins especiales para integración con Frameworks.

Compatibilidad: Lo podemos utilizar con Spring, Vert.x, Ktor y kotlinx.html.

====

== Android
* Compatibilidad
* Rendimiento
* Interoperabilidad
* Tamaño
* Tiempo de compilación
* Curva de aprendizaje

[NOTE.speaker]
====
Compatibilidad: Es totalmente compatible con el JDK 6, por lo que las aplicaciones desarrolladas con Kotlin pueden ser instaladas en dispositivos Android con versiones antiguas sin inconvenientes.

Rendimiento: Ofrece un rendimiento igual al de Java y en algunos casos superior.

Interoperabilidad: Al ser compatible con Java, las librerías existentes en Android se pueden usar en Kotlin.

Tamaño: El runtime para Android es chico, solo se agregan en promedio 100KB extras al apk.
	Tiempo de compilación: Ha sido optimizado para ser eficiente en compilación incremental.

Curva de aprendizaje: La transición Java a Kotlin es bastante sencilla, adicionalmente los IDEs ofrecen herramientas para convertir código Java a Kotlin. JetBrains también ofrece guías y tutoriales para los que deseen aprender.

====

== Sintaxis

== !

[source,java,linenums]
----
package com.proitc.kotlin

data class EstudianteKotlin(val nombre: String,
                            val puntaje: Int? = null)

fun main(args: Array<String>) {
  val estudiantes = listOf(EstudianteKotlin("Julia"),
      EstudianteKotlin("Marco", puntaje = 12),
      EstudianteKotlin(puntaje = 11, nombre = "Pedro"))

  val mayorPuntaje = estudiantes.maxBy { it.puntaje ?: 0 }

  println("""El mayor puntaje en Kotlin es de:
    $mayorPuntaje""")
}
----

[NOTE.speaker]
====
L1: Tenemos la declaración del paquete, y aunque parece similar a Java podemos observar que no hay “;” al final, esto es porque en Kotlin el uso de “;” es opcional.

L3-L4: En este bloque tenemos la declaración de una data class1, esta es un tipo de clase que podemos usar para almacenar datos. La podemos comparar con un Java Bean2 o un DTO3 donde el compilador genera por nosotros el constructor primario, métodos hashCode, equals, toString, copy, entre otros.
Otro aspecto importante que vemos es la declaración de propiedades con la palabra reservada “val”, con ella declaramos variables de solo lectura, que pueden ser inicializadas una sola vez, un efecto similar a lo que se lograría con el uso de la palabra reservada “final” en java, haciéndolas inmutables.
Considerar también que el tipo de la variable se define luego de su declaración, esto porque se le da prioridad al nombre de las variables con el objetivo de mejorar la legibilidad.

Adicionalmente vemos dos maneras de definir los tipos de datos, la primera colocándolo directamente como es el caso de String, y la otra agregándole un “?” al final. Esto es porque el compilador hace un control estricto de la nulabilidad, cuando agregamos el “?” le estamos diciendo que esta variable puede almacenar datos nulos, en el caso de que no lo hagamos nos dará un error de compilación. En nuestro caso si inicializamos un EstudianteKotlin con un nombre con valor null la aplicación no compilará.

L6: Aquí hacemos la declaración de la función main. Como podemos ver, a diferencia de Java, se pueden declarar funciones fuera de una clase.

L7-L9: En estás dos líneas se está creando una lista de EstudianteKotlin. Este lenguaje cuenta con una librería estándar para manejo de colecciones, de hecho, tiene variantes para manejar colecciones inmutables o mutables. En este caso listOf crea una lista inmutable. Podemos observar que no se usa la palabra “new” para instanciar objetos como en otros lenguajes. Otro punto importante es que en Kotlin no es necesario definir el tipo de dato en asignaciones o retorno de funciones, esto pues el compilador hace uso de inferencia de tipos (type inference) para determinarlo en tiempo de compilación; la variable “estudiantes” es una List inmutable con elementos de tipo EstudianteKotlin; toda esa información se obtiene en tiempo de compilación por cómo está declarado el método listOf de la librería estándar.

L8: Inicializamos un objeto usando parámetros nombrados (named parameters), esto nos permite llamar una función o constructor indicando los valores que toman los argumentos de manera explícita, la intención de esto es mejorar la legibilidad en funciones que tienen muchos parámetros. Incluso permite que se pasen los argumentos en distinto orden al que han sido declarados en la firma del método.

L11: Aquí usamos la función maxBy de la librería estándar de colecciones. El objetivo de esta función es retornar el primer elemento que tenga el mayor valor según la función indicada, o null si no hay elementos. Considerar que la función es enviada como una expresión lambda (Lambda Expression4), que no es otra cosa que una función anónima que puede ser usada como valor. Esta estructura viene de la programación funcional y la podemos usar puesto que Kotlin tiene la capacidad de combinar programación funcional con programación orientada a objetos.

El parámetro it de nuestro ejemplo es el nombre por defecto que toma el parámetro de una expresión lambda que recibe un sólo parámetro, en este caso un EstudianteKotlin.

El operador Elvis :? (sí, se llama así por el cantante) que aparece en la expresión evalúa la edad de los estudiantes y en caso de que sea null retorna 0. El objetivo de este operador es hacer un control de nulos de manera más concisa.

L13-14: Por último, imprimimos el resultado usando plantillas de cadenas de texto (String templates) las cuales evalúan el objeto precedido por el símbolo $, en nuestro caso mayorPuntaje, y lo concatenan en la cadena de texto. Al usar una data class en nuestro ejemplo se llama de manera implícita al método toString() obteniendo la salida que vimos anteriormente. Otro punto que podemos ver es que Kotlin literales de String de varias líneas.
====

== !
[source,java,linenums]
----
package com.proitc.java;

import static java.util.Comparator.comparingInt;

import java.util.List;

class MainJava {

  public static void main(String[] args) {
    final var estudiantes = List
        .of(new EstudianteJava("Julio"), new EstudianteJava("María", 12));
    final var mayorPuntaje = estudiantes.stream().max(comparingInt(es -> {
      if (es.getPuntaje() == null) {
        return 0;
      } else {
        return es.getPuntaje();
      }
    }));
    System.out
        .println(String.format("El mayor puntaje en Java es de: %s",
          mayorPuntaje.orElse(null)));
  }
}
----

== !
[source,java,linenums]
----
package com.proitc.java;

import java.util.Objects;

class EstudianteJava {

  private final String nombre;
  private final Integer puntaje;

  EstudianteJava(String nombre, Integer puntaje) {
    Objects.requireNonNull(nombre);
    this.nombre = nombre;
    this.puntaje = puntaje;
  }

  EstudianteJava(String nombre) {
    this(nombre, null);
  }

  public String getNombre() {
    return nombre;
  }

  public Integer getPuntaje() {
    return puntaje;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EstudianteJava person = (EstudianteJava) o;
    return Objects.equals(getNombre(), person.getNombre()) &&
        Objects.equals(getPuntaje(), person.getPuntaje());
  }

  @Override
  public int hashCode() {
    return Objects.hash(getNombre(), getPuntaje());
  }

  @Override
  public String toString() {
    return "EstudianteJava{" +
        "nombre='" + getNombre() + '\'' +
        ", puntaje=" + getPuntaje() +
        '}';
  }


}
----

[NOTE.speaker]
====
Código fuente completo:

*MainJava.java*
[source,java]
----
package com.proitc.java;

import static java.util.Comparator.comparingInt;

import java.util.List;

class MainJava {

  public static void main(String[] args) {
    final var estudiantes = List
        .of(new EstudianteJava("Julio"), new EstudianteJava("María", 12));
    final var mayorPuntaje = estudiantes.stream().max(comparingInt(es -> {
      if (es.getPuntaje() == null) {
        return 0;
      } else {
        return es.getPuntaje();
      }
    }));
    System.out
        .println(String.format("El mayor puntaje en Java es de: %s",
          mayorPuntaje.orElse(null)));
  }
}
----

*EstudianteJava.java*
[source,java]
----
package com.proitc.java;

import java.util.Objects;

class EstudianteJava {

  private final String nombre;
  private final Integer puntaje;

  EstudianteJava(String nombre, Integer puntaje) {
    Objects.requireNonNull(nombre);
    this.nombre = nombre;
    this.puntaje = puntaje;
  }

  EstudianteJava(String nombre) {
    this(nombre, null);
  }

  public String getNombre() {
    return nombre;
  }

  public Integer getPuntaje() {
    return puntaje;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EstudianteJava person = (EstudianteJava) o;
    return Objects.equals(getNombre(), person.getNombre()) &&
        Objects.equals(getPuntaje(), person.getPuntaje());
  }

  @Override
  public int hashCode() {
    return Objects.hash(getNombre(), getPuntaje());
  }

  @Override
  public String toString() {
    return "EstudianteJava{" +
        "nombre='" + getNombre() + '\'' +
        ", puntaje=" + getPuntaje() +
        '}';
  }


}
----

====


== Conclusiones
* Sintaxis moderna
* Inferencia de tipos
* Control de nulos
* Sintaxis flexible y programación asincrónica
* Compatible con Java

[NOTE.speaker]
====
Kotlin es un lenguaje Open Source moderno con muchas características como: soporte de inferencia de tipos, control de nulos en tiempo de compilación, programación asíncrona y sintaxis flexible. Además, es compatible con el ecosistema Java y podemos usarlo en backend de servidores y aplicaciones Android.

A esto podemos agregar que nos permite combinar programación orientada objetos y funcional con una sintaxis amigable y expresiva.

Al compararlo con Java vemos que una de las principales diferencias es lo conciso y expresivo de su código.

====

include::self.ad[]
